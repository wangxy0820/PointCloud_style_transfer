import torch
import numpy as np
from typing import Tuple, List, Optional
from sklearn.neighbors import NearestNeighbors
from scipy.spatial.distance import cdist
import time


class PointCloudMetrics:
    """点云评估指标计算器"""
    
    def __init__(self, device: str = 'cuda'):
        self.device = torch.device(device if torch.cuda.is_available() else 'cpu')
    
    def chamfer_distance(self, pred: torch.Tensor, target: torch.Tensor, 
                        bidirectional: bool = True) -> torch.Tensor:
        """
        计算Chamfer距离
        Args:
            pred: 预测点云 [B, N, 3]
            target: 目标点云 [B, M, 3]
            bidirectional: 是否计算双向距离
        Returns:
            Chamfer距离
        """
        # 计算距离矩阵
        dist_matrix = torch.cdist(pred, target, p=2)  # [B, N, M]
        
        # 最近邻距离
        dist_pred_to_target = torch.min(dist_matrix, dim=2)[0]  # [B, N]
        chamfer_pred_to_target = torch.mean(dist_pred_to_target, dim=1)  # [B]
        
        if bidirectional:
            dist_target_to_pred = torch.min(dist_matrix, dim=1)[0]  # [B, M]
            chamfer_target_to_pred = torch.mean(dist_target_to_pred, dim=1)  # [B]
            return chamfer_pred_to_target + chamfer_target_to_pred
        else:
            return chamfer_pred_to_target
    
    def earth_mover_distance(self, pred: torch.Tensor, target: torch.Tensor) -> torch.Tensor:
        """
        计算Earth Mover's Distance (使用最小二分图匹配的近似)
        Args:
            pred: 预测点云 [B, N, 3]
            target: 目标点云 [B, N, 3]
        Returns:
            EMD距离
        """
        batch_size = pred.size(0)
        device = pred.device
        
        emd_values = []
        
        for b in range(batch_size):
            pred_points = pred[b].cpu().numpy()  # [N, 3]
            target_points = target[b].cpu().numpy()  # [N, 3]
            
            # 计算成本矩阵
            cost_matrix = cdist(pred_points, target_points)
            
            # 使用匈牙利算法的近似（贪心匹配）
            n_points = pred_points.shape[0]
            used_target = set()
            total_cost = 0
            
            # 为每个预测点找到最佳匹配
            for i in range(n_points):
                min_cost = float('inf')
                best_j = -1
                
                for j in range(n_points):
                    if j not in used_target and cost_matrix[i, j] < min_cost:
                        min_cost = cost_matrix[i, j]
                        best_j = j
                
                if best_j != -1:
                    total_cost += min_cost
                    used_target.add(best_j)
            
            emd_values.append(total_cost / n_points)
        
        return torch.tensor(emd_values, device=device, dtype=pred.dtype)
    
    def hausdorff_distance(self, pred: torch.Tensor, target: torch.Tensor) -> torch.Tensor:
        """
        计算Hausdorff距离
        Args:
            pred: 预测点云 [B, N, 3]
            target: 目标点云 [B, M, 3]
        Returns:
            Hausdorff距离
        """
        # 计算距离矩阵
        dist_matrix = torch.cdist(pred, target, p=2)  # [B, N, M]
        
        # 双向最大最小距离
        max_min_dist1 = torch.max(torch.min(dist_matrix, dim=2)[0], dim=1)[0]  # [B]
        max_min_dist2 = torch.max(torch.min(dist_matrix, dim=1)[0], dim=1)[0]  # [B]
        
        return torch.max(max_min_dist1, max_min_dist2)
    
    def frechet_point_cloud_distance(self, pred_features: torch.Tensor, 
                                   target_features: torch.Tensor) -> float:
        """
        计算Fréchet Point Cloud Distance (基于特征)
        Args:
            pred_features: 预测点云特征 [B, D]
            target_features: 目标点云特征 [B, D]
        Returns:
            FPD距离
        """
        # 转换为numpy
        pred_feat = pred_features.cpu().numpy()
        target_feat = target_features.cpu().numpy()
        
        # 计算均值和协方差
        mu1, sigma1 = np.mean(pred_feat, axis=0), np.cov(pred_feat, rowvar=False)
        mu2, sigma2 = np.mean(target_feat, axis=0), np.cov(target_feat, rowvar=False)
        
        # 计算FID公式（适用于FPD）
        diff = mu1 - mu2
        
        # 计算协方差的平方根
        try:
            sqrt_sigma = np.real(np.sqrt(np.dot(sigma1, sigma2)))
            if np.iscomplexobj(sqrt_sigma):
                sqrt_sigma = np.real(sqrt_sigma)
        except:
            # 如果计算失败，使用近似
            sqrt_sigma = np.sqrt(np.trace(np.dot(sigma1, sigma2)))
        
        fid = np.sum(diff**2) + np.trace(sigma1 + sigma2 - 2*sqrt_sigma)
        
        return float(fid)
    
    def coverage_score(self, pred: torch.Tensor, target: torch.Tensor, 
                      k: int = 5) -> float:
        """
        计算覆盖度分数
        Args:
            pred: 预测点云 [B, N, 3]
            target: 目标点云 [B, M, 3]
            k: 近邻数量
        Returns:
            覆盖度分数
        """
        batch_size = pred.size(0)
        coverage_scores = []
        
        for b in range(batch_size):
            pred_points = pred[b].cpu().numpy()  # [N, 3]
            target_points = target[b].cpu().numpy()  # [M, 3]
            
            # 使用KNN找到目标点云中每个点的k个最近邻
            nbrs = NearestNeighbors(n_neighbors=k).fit(target_points)
            distances, indices = nbrs.kneighbors(pred_points)
            
            # 计算有多少目标点被覆盖
            covered_indices = set(indices.flatten())
            coverage = len(covered_indices) / len(target_points)
            coverage_scores.append(coverage)
        
        return np.mean(coverage_scores)
    
    def minimum_matching_distance(self, pred: torch.Tensor, target: torch.Tensor) -> torch.Tensor:
        """
        计算最小匹配距离
        Args:
            pred: 预测点云 [B, N, 3]
            target: 目标点云 [B, N, 3]
        Returns:
            最小匹配距离
        """
        batch_size = pred.size(0)
        device = pred.device
        
        mmd_values = []
        
        for b in range(batch_size):
            pred_points = pred[b]  # [N, 3]
            target_points = target[b]  # [N, 3]
            
            # 计算距离矩阵
            dist_matrix = torch.cdist(pred_points.unsqueeze(0), target_points.unsqueeze(0))[0]
            
            # 使用匈牙利算法找到最优匹配
            from scipy.optimize import linear_sum_assignment
            row_ind, col_ind = linear_sum_assignment(dist_matrix.cpu().numpy())
            
            # 计算最小匹配距离
            mmd = dist_matrix[row_ind, col_ind].mean()
            mmd_values.append(mmd.item())
        
        return torch.tensor(mmd_values, device=device, dtype=pred.dtype)
    
    def local_feature_statistics(self, points: torch.Tensor, k: int = 8) -> dict:
        """
        计算局部特征统计
        Args:
            points: 点云 [B, N, 3]
            k: 近邻数量
        Returns:
            特征统计字典
        """
        batch_size, num_points, _ = points.shape
        stats = {
            'mean_k_distance': [],
            'std_k_distance': [],
            'mean_local_density': [],
            'std_local_density': []
        }
        
        for b in range(batch_size):
            point_cloud = points[b].cpu().numpy()  # [N, 3]
            
            # 使用KNN计算k近邻
            nbrs = NearestNeighbors(n_neighbors=k+1).fit(point_cloud)  # +1因为包含自身
            distances, indices = nbrs.kneighbors(point_cloud)
            
            # 排除自身（第一个邻居）
            k_distances = distances[:, 1:]  # [N, k]
            
            # 计算统计量
            mean_distances = np.mean(k_distances, axis=1)  # [N]
            local_densities = 1.0 / (np.mean(k_distances, axis=1) + 1e-8)  # [N]
            
            stats['mean_k_distance'].append(np.mean(mean_distances))
            stats['std_k_distance'].append(np.std(mean_distances))
            stats['mean_local_density'].append(np.mean(local_densities))
            stats['std_local_density'].append(np.std(local_densities))
        
        # 计算批次平均值
        return {k: np.mean(v) for k, v in stats.items()}
    
    def uniformity_score(self, points: torch.Tensor, k: int = 8) -> float:
        """
        计算点云均匀性分数
        Args:
            points: 点云 [B, N, 3]
            k: 近邻数量
        Returns:
            均匀性分数
        """
        batch_size = points.size(0)
        uniformity_scores = []
        
        for b in range(batch_size):
            point_cloud = points[b].cpu().numpy()  # [N, 3]
            
            # 计算k近邻距离
            nbrs = NearestNeighbors(n_neighbors=k+1).fit(point_cloud)
            distances, _ = nbrs.kneighbors(point_cloud)
            k_distances = distances[:, 1:]  # 排除自身
            
            # 计算距离的变异系数
            mean_distances = np.mean(k_distances, axis=1)
            overall_mean = np.mean(mean_distances)
            overall_std = np.std(mean_distances)
            
            # 均匀性 = 1 - 变异系数
            coefficient_of_variation = overall_std / (overall_mean + 1e-8)
            uniformity = 1.0 / (1.0 + coefficient_of_variation)
            uniformity_scores.append(uniformity)
        
        return np.mean(uniformity_scores)
    
    def compute_all_metrics(self, pred: torch.Tensor, target: torch.Tensor,
                           pred_features: Optional[torch.Tensor] = None,
                           target_features: Optional[torch.Tensor] = None) -> dict:
        """
        计算所有评估指标
        Args:
            pred: 预测点云 [B, N, 3]
            target: 目标点云 [B, M, 3]
            pred_features: 预测点云特征 (可选)
            target_features: 目标点云特征 (可选)
        Returns:
            所有指标的字典
        """
        start_time = time.time()
        
        metrics = {}
        
        # 几何距离指标
        metrics['chamfer_distance'] = self.chamfer_distance(pred, target).mean().item()
        
        # 如果点数相同，计算EMD和MMD
        if pred.size(1) == target.size(1):
            metrics['earth_mover_distance'] = self.earth_mover_distance(pred, target).mean().item()
            metrics['minimum_matching_distance'] = self.minimum_matching_distance(pred, target).mean().item()
        
        metrics['hausdorff_distance'] = self.hausdorff_distance(pred, target).mean().item()
        
        # 覆盖度指标
        metrics['coverage_score'] = self.coverage_score(pred, target)
        
        # 均匀性指标
        metrics['uniformity_score'] = self.uniformity_score(pred)
        
        # 局部特征统计
        local_stats = self.local_feature_statistics(pred)
        metrics.update({f'pred_{k}': v for k, v in local_stats.items()})
        
        target_local_stats = self.local_feature_statistics(target)
        metrics.update({f'target_{k}': v for k, v in target_local_stats.items()})
        
        # 特征距离（如果提供特征）
        if pred_features is not None and target_features is not None:
            metrics['frechet_point_cloud_distance'] = self.frechet_point_cloud_distance(
                pred_features, target_features
            )
        
        # 计算时间
        metrics['computation_time'] = time.time() - start_time
        
        return metrics


class ClassificationMetrics:
    """分类任务评估指标"""
    
    def __init__(self):
        pass
    
    def accuracy(self, pred: torch.Tensor, target: torch.Tensor) -> float:
        """计算准确率"""
        correct = (pred.argmax(dim=1) == target).float()
        return correct.mean().item()
    
    def top_k_accuracy(self, pred: torch.Tensor, target: torch.Tensor, k: int = 5) -> float:
        """计算Top-K准确率"""
        _, top_k_pred = pred.topk(k, dim=1)
        correct = top_k_pred.eq(target.view(-1, 1).expand_as(top_k_pred))
        return correct.any(dim=1).float().mean().item()
    
    def confusion_matrix(self, pred: torch.Tensor, target: torch.Tensor, num_classes: int) -> np.ndarray:
        """计算混淆矩阵"""
        pred_labels = pred.argmax(dim=1).cpu().numpy()
        target_labels = target.cpu().numpy()
        
        cm = np.zeros((num_classes, num_classes), dtype=np.int64)
        for p, t in zip(pred_labels, target_labels):
            cm[t, p] += 1
        
        return cm


def test_metrics():
    """测试评估指标"""
    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    
    # 创建测试数据
    batch_size = 4
    num_points = 1024
    pred = torch.randn(batch_size, num_points, 3).to(device)
    target = torch.randn(batch_size, num_points, 3).to(device)
    
    # 初始化指标计算器
    metrics = PointCloudMetrics(device=device)
    
    # 计算所有指标
    all_metrics = metrics.compute_all_metrics(pred, target)
    
    print("Point Cloud Metrics:")
    for metric, value in all_metrics.items():
        print(f"{metric}: {value:.6f}")
    
    # 测试分类指标
    class_metrics = ClassificationMetrics()
    pred_logits = torch.randn(batch_size, 10).to(device)
    class_targets = torch.randint(0, 10, (batch_size,)).to(device)
    
    accuracy = class_metrics.accuracy(pred_logits, class_targets)
    top5_acc = class_metrics.top_k_accuracy(pred_logits, class_targets, k=5)
    
    print(f"\nClassification Metrics:")
    print(f"Accuracy: {accuracy:.4f}")
    print(f"Top-5 Accuracy: {top5_acc:.4f}")


if __name__ == "__main__":
    test_metrics()